\documentclass[11pt,a4paper,titlepage]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\newcommand{\titulo}{\textit{Relatório I - Unidade Lógica Aritmética}}

\newcommand{\cabecalho}{\textit{Relatório I}}

\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{setspace}
\usepackage{graphicx,url}
%\usepackage{color,colortbl}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{wrapfig}
\usepackage{times}
\usepackage{hyphenat}
\usepackage{ae}
\usepackage{algorithm}
\usepackage[sort,numbers]{natbib}
%package to insert codes
\usepackage{listings}
\usepackage{mips}
\usepackage{tabularx}
%appendix
\usepackage[titletoc,toc,page]{appendix}
\renewcommand{\appendixtocname}{Apêndices}
\renewcommand{\appendixpagename}{Apêndices}

% the following is needed for syntax highlighting
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %código assembly
  language=[mips]Assembler,       % the language of the code
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=4,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add a comment within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}
\usepackage{xcolor}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}
%mostrar código do verilog
\lstdefinestyle{verilog-style}
{
    language=Verilog,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    tabsize=8,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1
}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\usepackage{trace}

% Criar figura dividida em subfiguras
\usepackage{subfigure}

\usepackage{subfig}
\usepackage{ae}
\usepackage{aecompl}

\usepackage{multirow}
%\usepackage{epstopdf}

\pagestyle{fancy}

\setlength{\evensidemargin}{0.0in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\textwidth}{6.6in}
\setlength{\textheight}{1.06\textheight}

\lhead{}
\chead{}
\rhead{\footnotesize{\textsc{\cabecalho}}}
\lfoot{\footnotesize{Guilherme Batista Santos, Iuri Silva Castro, João Mateus de Freitas Veneroso, Ricardo Pagoto Marinho}}
\cfoot{}
\rfoot{\footnotesize{\thepage}}
\setlength{\headwidth}{\textwidth}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\baselinestretch}{0.90}

%\hyphenation{ ca-rac-te-ri-zan-do--se }

\begin{document}

\begin{titlepage}
\begin{center}

\begin{large}
Universidade Federal de Minas Gerais\\
Instituto de Ciências Exatas\\
Departamento de Ciência da Computação\\
\end{large}

\vspace{20mm}

\begin{Large}
DCC819 - Arquitetura de Computadores
\end{Large}

\vspace{20mm}

\begin{LARGE}
\titulo
\end{LARGE}


\vspace{30mm}

\begin{Large}
\begin{center}
Guilherme Batista Santos\\ Iuri Silva Castro\\ João Mateus de Freitas Veneroso\\ Ricardo Pagoto Marinho \\
\end{center}
\end{Large}


\vspace{60mm}

{\sc Belo Horizonte - MG}

{\sc \today}
%{\sc 05 de Maro de 2012}

%\vspace{10mm}
\end{center}
\end{titlepage}


\section{Introdução}\label{sec:intro}

O presente trabalho foca na descrição da implementação de uma Unidade Lógica e Aritmética (ULA) em Verilog HDL, uma Linguagem de descrição de hardware, \textit{Hardware Description Language} - HDL - em inglês.
A ULA é um circuito digital responsável por realizar operações lógicas e aritméticas no caminho de dados de uma CPU.
É a ULA que realiza operações como adição, subtração e operações lógicas como \textit{and} e \textit{or}.
Além disso, ela também é responsável por calcular o endereço de memória para escrita ou leitura quando as instruções requisitam.
Para implementar a ALU, utilizamos a IDE \textit{Quartus II 13} junto com \textit{ModelSim} para simular uma FPGA e fazer os testes necessários.
Os testes em dispositivo físico foram feitos no módulo de prototipação DE2.

\section{ULA}\label{sec:ula}

A Figura~\ref{fig:ula} mostra o desenho esquemático de uma ULA.


\begin{figure}[h]
\centering
\includegraphics[]{images/ULA.png}
\caption{Desenho esquemático de uma ULA.}
\label{fig:ula}
\end{figure}

Nela, é possível ver que a ULA possui duas entradas e uma saída de dados,~\textit{A}, \textit{B} e~\textit{R} respectivamente, além de uma entrada e uma saída de sinais de controle,~\textit{F} e~\textit{D}.
As entradas \textit{A} e~\textit{B} são os valores que a ULA recebe para fazer os cálculos necessários.
Esses valores podem vir de registradores ou podem ser imediatos: números absolutos, como nas instruções a seguir:

\begin{lstlisting}
Addi R1,R2,10
Sub R3,R4,R5
\end{lstlisting}

A instrução 1 soma o valor imediato 10 ao valor armazenado no registrador \textit{R2} e armazena no registrador \textit{R1}.
No caso dessa instrução, a entrada~\textit{A} na Figura~\ref{fig:ula} recebe o valor do registrador~\textit{R2}, a entrada~\textit{B} o valor do imediato (10) e a saída~\textit{R} terá o valor da soma, sendo que este valor será armazenado no registrador~\textit{R1}.
Já a instrução 2 subtrai o valor armazenado no registrador~\textit{R5} do valor armazenado em~\textit{R4} e armazena em~\textit{R3}, fazendo a operação

\begin{equation}
\label{eq1:sub-ula}
R3=R4-R5
\end{equation}

A entrada de sinais~\textit{F} é a entrada de controles da ALU.
Dentre esses sinais de controle está o que sinaliza se o valor na entrada de dados~\textit{B} é o valor vindo de um registrador ou um imediato.
Esse sinal controla um multiplexador para selecionar qual entrada irá passar para a ALU, a entrada vinda do banco de registradores ou a entrada vinda direto da instrução no caso de um imediato.

Já a saída de sinais~\textit{D}, são os sinais que a ALU indica, sendo eles se o resultado é zero, negativo e se houve~\textit{overflow} na operação.

\section{Descrição}\label{sec:desc}

\subsection{Código}\label{subsec:codigo}

O problema atacado neste trabalho foi implementar uma ULA em \textit{Verilog} HDL.
Para isso foi especificado que a ULA deve possuir entradas para dois operandos de 16 bits e um entrada para o código da operação a ser executada, que possui 4 bits.
Para este trabalho, utilizamos apenas 16 registradores, ou seja, apenas 4 bits são necessários para fazer o endereçamento no banco de registradores.

A ULA desenvolvida é capaz de realizar as operações descritas na Tabela~\ref{tab:ULA}.

\begin{table}[h]
\centering
\begin{tabular}{| c | c | c | l |}
\hline
Código & Instrução & Operação & Descrição\\
\hline
0 & ADD \$s4,\$s3,\$s2 & \$s4=\$s2+\$s3 & Adição entre registros\\
\hline
1 & SUB \$s4,\$s3,\$s2 & \$s4=\$s2-\$s3 & Subtração entre registros \\
\hline
2 & SLTI \$s4,imm,\$s2 & \$s2>imm?\$s4=1:\$s4=0 & Comparação entre registro e imediato \\
\hline
3 & AND \$s4,\$s3,\$s2 & \$s4=\$s2\&\$s3 & \textit{AND} lógico com dois registros\\
\hline
4 & OR \$s4,\$s3,\$s2 &  \$s4=\$s2|\$s3 & \textit{OR} lógico com dois registros\\
\hline
5 & XOR \$s4,\$s3,\$s2 &  \$s4=\$s2\^\$s3 & \textit{XOR} lógico com dois registros\\
\hline
6 & ANDI \$s4,imm,\$s2 & \$s4=\$s2\&imm & \textit{AND} lógico com um registro e um imediato\\
\hline
7 & ORI \$s4,imm,\$s2 & \$s4=\$s2|imm & \textit{OR} lógico com um registro e um imediato \\
\hline
8 & XORI \$s4,imm,\$s2 & \$s4=\$s2\^imm & \textit{XOR} lógico com um registro e um imediato \\
\hline
9 & ADDI \$s4,imm,\$s2 & \$s4=\$s2+imm & Adição entre registro e um imediato\\
\hline
10 & SUBI \$s4,imm,\$s2 & \$s4=\$s2+imm & Subtração entre registro e um imediato\\
\hline
\end{tabular}
\caption{Descrição das operações requisitadas.}
\label{tab:ULA}
\end{table}
\captionsetup{font={footnotesize,rm},justification=centering,labelsep=period}%

Ou seja, a ULA implementada deve ser capaz de realizar 11 operações diferentes.
Observe que é possível, além de fazer operações com registradores, realizar operações com imediatos, \textit{i.e.}, números absolutos.
Esses números devem possuir 4 bits de largura.

Como saída, a ULA deve entregar o resultado da operação solicitada e um conjunto de sinais relativos ao resultado da operação.
O resultado possui 16 bits para que seja armazenado em um registrador de destino e o conjunto de sinais são 3, como mostrado na Tabela~\ref{tab:flags}.

\begin{table}[h]
\centering
\begin{tabular}{| c | c |}
\hline
Índice & Sinal\\
\hline
0 & \textit{Overflow}\\
\hline
1 & Negativo \\
\hline
2 & Zero\\
\hline
\end{tabular}
\caption{Sinais de saída da ULA.}
\label{tab:flags}
\end{table}
\captionsetup{font={footnotesize,rm},justification=centering,labelsep=period}%

\subsection{Prototipação}\label{subsec:prot}

A FPGA utilizada para a prototipação possui 4 botões para que possamos inserir dados e realizar as operações, 16 \textit{switches} para informar o valor dos dados inseridos e 8 \textit{displays} que mostram o valor dos dados.
Cada \textit{switch} possui dois estados: \textit{cima} e \textit{baixo}.
Quando um \textit{switch} está no estado \textit{cima}, ele possui valor 1, e quando está no estado \textit{baixo}, ele possui valor 0.
Desta forma, cada \textit{switch} se comporta com 1 bit do dado.

Quando o botão de nome \textit{KEY0} for apertado, os \textit{displays HEX7} e \textit{HEX6} mostram o valor no conjunto de \textit{switches} \textit{SW8} a \textit{SW11} (4 bits) e os \textit{displays HEX5} e \textit{HEX4} mostram o valor no conjunto de \textit{switches} \textit{SW4} a \textit{SW7} (4 bits).
Desta forma, é possível visualizar os valores passados para a placa.

Se apertarmos o botão \textit{KEY3}, os \textit{switches} serão interpretados como uma instrução completa, ou seja, com código da operação e operandos de entrada e saída, sendo que o \textit{switch SW0} é o menos significativo enquanto o \textit{SW15} o mais significativo.
Assim, cada instrução possui 16 bits, como especificado no documento.
O conjunto de \textit{switches} \textit{SW0} a \textit{SW3} indica a entrada \textit{A} e do \textit{switch SW4} ao \textit{SW7}, a entrada \textit{B} da Figura~\ref{fig:ula}.
Lembrando que a entrada \textit{B} pode ser um imediato.
Já o conjunto de \textit{switches SW8} a \textit{SW11} indica a saída do resultado (saída R na Figura~\ref{fig:ula}), enquanto os \textit{switches SW12} a \textit{SW15} indicam a operação a ser realizada, \textit{i.e.}, o código da operação.

A Figura~\ref{fig:fpga} mostra a divisão na placa.

\begin{figure}[h]
\centering
\includegraphics[]{images/fpga.png}
\caption{FPGA.}
\label{fig:fpga}
\end{figure}


\section{Implementação}

\subsection{ULA}\label{subsec:imp-ula}
Esta seção fala da implementação da ULA em \textit{Verilog}.
Nela, mostramos como a ULA foi implementada além de decisões de projeto tomadas.

O módulo desenvolvido possui 5 entradas e duas saídas: \textit{OpA}, \textit{OpB}, \textit{Op}, \textit{RST}, \textit{CLK}, \textit{Res} e \textit{FlagReg} respectivamente.
%O Apêndice~\ref{app:ULA} mostra o código.

As entradas \textit{OpA} e \textit{OpB} representam as entradas \textit{A} e \textit{B} da Figura~\ref{fig:ula}.
A entrada \textit{Op} indica qual operação a ALU vai fazer (Add, Sub, etc.) e faz parte da entrada \textit{F} na Figura~\ref{fig:ula}.
As saídas \textit{Res} e \textit{FlagReg} indicam, respectivamente o resultado da operação e o sinal de saída da ALU, na Figura~\ref{fig:ula}, as saídas \textit{R} e \textit{D} respectivamente.

Na implementação, as entradas \textit{OpA} e \textit{OpB} são de \textit{16 bits}, que, de acordo com a especificação do trabalho, é o tamanho dos registradores.
Aqui, apenas o \textit{OpB} pode ser um imediato.
Neste caso, o imediato possui apenas \textit{4 bits}, sendo necessário estender mais \textit{12 bits}.
Mais a frente será mostrado como e onde essa operação é feita.
A entrada \textit{Op} indica a operação a ser realizada e possui \textit{4 bits}, ou seja, a ALU implementada possui um máximo de 16 operações diferentes.

As entradas \textit{RST} e \textit{CLK} possuem a função de reiniciar os valores de entrada, caso necessário, e dar o \textit{clock} da máquina respectivamente.
Assim, a cada subida de \textit{clock}, uma operação é realizada.

A saída \textit{Res} possui \textit{16 bits}, assim como as entradas \textit{OpA} e \textit{OpB} já que é o resultado da operação e a saída \textit{FlagReg} possui \textit{3 bits}, um para cada sinal de saída.

Decidimos fazer uma ULA genérica, ou seja, não diferenciamos instruções para imediatos, deixando para outra unidade o trabalho de identificar se a instrução utilizada é com um imediato ou não.
Assim, criou-se uma ULA com as operações mostradas na Tabela~\ref{tab:imp}.

\begin{table}[h]
\centering
\begin{tabular}{| c | c |}
\hline
Código  & Operação \\
\hline
0000 & Adição\\
\hline
0001 & Subtração\\
\hline
0010 & Comparação\\
\hline
0011 & \textit{AND} lógico\\
\hline
0100 & \textit{OR} lógico\\
\hline
0101 & \textit{XOR} lógico\\
\hline
\end{tabular}
\caption{Descrição das operações implementadas.}
\label{tab:imp}
\end{table}
\captionsetup{font={footnotesize,rm},justification=centering,labelsep=period}%

\subsection{Banco de registradores}\label{subsec:imp-br}

Para carregar e armazenar valores dos registradores, um banco de registradores foi necessário.
O banco de registradores implementado consiste em 16 registradores de 16 bits cada.
No início das simulações e dos testes, o banco inteiro foi inicializado com o valor 0, ou seja, todos os registradores, inicialmente, possuem o valor 0.

O módulo do banco possui como entrada os endereços de dois registradores de entrada, \textit{AddrRegA} e \textit{AddrRegB}, o endereço de um registrador para escrita, \textit{AddrWriteReg}, o dado de escrita, \textit{data}, e três sinais:

\begin{itemize}
\item WEN -> \textit{Write Enable}
\item RST -> \textit{Reset}
\item CLK -> \textit{Clock} 
\end{itemize}

O primeiro sinal, WEN, indica se o banco será lido ou escrito.
Ele será escrito, caso WEN=1 e lido caso WEN=0.
Se quisermos escrever no banco, então o endereço do registrador para escrita é utilizado e o dado é escrito naquele registrador.
Se quisermos ler do banco, então utilizamos as duas saídas do banco de registradores, que são os valores que serão utilizados como entrada da ULA.
A saída \textit{RegA} se conecta à entrada \textit{OpA} do módulo da ULA, enquanto a saída \textit{RegB}, se conecta à entrada \textit{OpB} do módulo da ULA.
Lembrando que essa entrada da ULA pode ser um imediato, a decisão de pegar a saída do banco de registradores ou o imediato será discutida mais a frente.

\section{Experimentos}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
Instrução & Operando A & Operando B & Resultado & O & N & Z \\
\hline
ADD & 0011 1111 1111 1111 & 0100 0000 0000 0000 & 0111 1111 1111 1111 & 0 & 0 & 0 \\
ADD & 0100 0000 0000 0000 & 0100 0000 0000 0000 & 1000 0000 0000 0000 & 1 & 1 & 0 \\
ADD & 0000 0000 0000 0000 & 0000 0000 0000 0000 & 0000 0000 0000 0000 & 0 & 0 & 1 \\
ADD & 0010 0000 0000 0000 & 1100 0000 0000 0000 & 1110 0000 0000 0000 & 0 & 1 & 0 \\
SUB & 0100 0000 0000 0000 & 0011 1111 1111 1111 & 0000 0000 0000 0001 & 0 & 0 & 0 \\
SUB & 0011 1111 1111 1111 & 0100 0000 0000 0000 & 1111 1111 1111 1111 & 0 & 1 & 0 \\
SLT & 0100 0000 0000 0000 & 0000 0000 0000 0000 & 0000 0000 0000 0001 & 0 & 0 & 0 \\
SLT & 0000 0000 0000 0000 & 0100 0000 0000 0000 & 0000 0000 0000 0000 & 0 & 0 & 1 \\
AND & 0111 1111 1111 1111 & 0011 1111 1111 1111 & 0011 1111 1111 1111 & 0 & 0 & 0 \\
OR  & 0000 0000 1111 1111 & 1111 1111 0000 0000 & 1111 1111 1111 1111 & 0 & 1 & 0 \\
XOR & 0101 0101 0101 0101 & 0010 1010 1010 1010 & 0111 1111 1111 1111 & 0 & 0 & 0 \\
\hline

\end{tabular}
\caption{Experimentos.}
\label{tab:experiments}
\end{table}
\captionsetup{font={footnotesize,rm},justification=centering,labelsep=period}%

Alguns experimentos foram realizados com o intuito de testar as funcionalidades da Unida Lógica Aritmética
implementada em Verilog HDL. Observe que a ULA não distingue operações com registradores e imediatos, uma 
vez que os operandos A e B são tratados pelo módulo \textit{Decoder} e transformados em sua representação 
númerica de 16 bits antes de serem encaminhados à ULA. Durante o estágio de decodificação, os valores dos 
registradores enderaçados pela instrução são lidos do banco de registradores e um \textit{padding} de 12 
bits é concatenado ao valor dos operandos imediatos. Dessa forma, a ULA precisa executar apenas seis tipos 
de instruções: ADD, SUB, SLT, AND, OR e XOR. 

A tabela \ref{tab:experiments} descreve os resultados de onze  instruções e o valor das \textit{flags} da 
ULA após o término de cada operação. As colunas O, N e Z se referem respectivamente às flags \textit{Overflow}, 
\textit{Negative} e \textit{Zero}. Os experimentos também estão descritos no formato de um \textit{Test Bench} 
implementado no arquivo "\textit{ULA.v}".

%\begin{appendices}
%	\chapter{Módulo ULA}
%	\label{app:ULA}
%	\begin{lstlisting}[style={verilog-style}]
%module ULA (OpA, OpB, Res, Op, FlagReg, CLK, RST);
%
%	input CLK, RST;
%	input [3:0] Op;
%	input [15:0] OpA, OpB;
%	output reg [15:0] Res;
%	output reg [2:0] FlagReg;		// [Z N C]: Z=Zero; N=Neg; C=Carry/Overflow
%	
%	wire [15:0] invOpB;
%	assign invOpB = ~OpB + 16'd1;
%
%	parameter InsADD = 4'b0000;	// ADD	Res = OpA + OpB
%	parameter InsSUB = 4'b0001;	// SUB	Res = OpA - OpB
%	parameter InsSLT = 4'b0010;	// SLTI	Res = (OpA > OpB) ? 1 : 0
%	parameter InsAND = 4'b0011;	// AND 	Res = OpA & OpB
%	parameter InsOR =  4'b0100;	// OR 	Res = OpA | OpB
%	parameter InsXOR = 4'b0101;	// XOR 	Res = OpA ^ OpB
%	
%	parameter OverflowFlag	= 0;
%	parameter NegFlag 		= 1;
%	parameter ZeroFlag		= 2;
%	
%	always @(posedge CLK) begin
%	 if (RST) begin
%	  FlagReg = 3'b000;
%	 end
%	 else begin
%	  case (Op)
%	   InsADD: begin			
%	    Res = OpA + OpB;
%					
%	    /* Zero check */
%	    if (Res == 0)
%		 FlagReg[ZeroFlag] = 1'b1;
%	    else
%	     FlagReg[ZeroFlag] = 1'b0;
%	    /* Overflow check */
%	    FlagReg[OverflowFlag] = (OpA[15] & OpB[15] & ~Res[15]) | (~OpA[15] & ~OpB[15] & Res[15]);
%	    /* Negative check */
%	    FlagReg[NegFlag] = Res[15];
%	   end
%	   InsSUB: begin			
%	    Res = OpA + invOpB;
%	    /* Zero check */
%	    if (Res == 0)
%	     FlagReg[ZeroFlag] = 1'b1;
%	    else
%	     FlagReg[ZeroFlag] = 1'b0;
%	    /* Overflow check */
%	    FlagReg[OverflowFlag] = (OpA[15] & invOpB[15] & ~Res[15]) | (~OpA[15] & ~invOpB[15] & Res[15]);
%	    /* Negative check */
%	    FlagReg[NegFlag] = Res[15];
%	   end
%	   InsSLT: begin
%	    if (OpA > OpB)
%	     Res = 16'd1;
%	    else
%	     Res = 16'd0;
%	    /* Zero check */
%	    if (Res == 0)
%	     FlagReg[ZeroFlag] = 1'b1;
%	    else
%	     FlagReg[ZeroFlag] = 1'b0;
%	    /* Overflow check */
%	    FlagReg[OverflowFlag] = (OpA[15] & OpB[15] & ~Res[15]) | (~OpA[15] & ~OpB[15] & Res[15]);
%	    /* Negative check */
%	    FlagReg[NegFlag] = Res[15];
%	   end
%	   InsAND: begin			
%	    Res = OpA & OpB;
%	    /* Zero check */
%	    if (Res == 0)
%	     FlagReg[ZeroFlag] = 1'b1;
%	    else
%	     FlagReg[ZeroFlag] = 1'b0;
%	    /* Overflow check */
%	    FlagReg[OverflowFlag] = (OpA[15] & OpB[15] & ~Res[15]) | (~OpA[15] & ~OpB[15] & Res[15]);
%	    /* Negative check */
%	    FlagReg[NegFlag] = Res[15];
%	   end
%	   InsOR: begin			
%	    Res = OpA | OpB;
%	    /* Zero check */
%	    if (Res == 0)
%	     FlagReg[ZeroFlag] = 1'b1;
%	    else
%	     FlagReg[ZeroFlag] = 1'b0;
%	    /* Overflow check */
%	    FlagReg[OverflowFlag] = (OpA[15] & OpB[15] & ~Res[15]) | (~OpA[15] & ~OpB[15] & Res[15]);
%	    /* Negative check */
%	    FlagReg[NegFlag] = Res[15];
%	   end
%	   InsXOR: begin			
%	    Res = OpA ^ OpB;
%	    /* Zero check */
%	    if (Res == 0)
%	     FlagReg[ZeroFlag] = 1'b1;
%	    else
%	     FlagReg[ZeroFlag] = 1'b0;
%	    /* Overflow check */
%	    FlagReg[OverflowFlag] = (OpA[15] & OpB[15] & ~Res[15]) | (~OpA[15] & ~OpB[15] & Res[15]);
%	    /* Negative check */
%	    FlagReg[NegFlag] = Res[15];
%	   end
%	  endcase
%	 end
%	end
%endmodule
%	\end{lstlisting}
%\end{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para mudar o nome da seo de referncias
%\renewcommand{\bibname}{Referncias}
%\renewcommand{\refname}{Referncias}

\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Referências}
\bibliography{references}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\appendix
%
%\pagebreak
%\section{Artigo submetido ao \textit{ACM Transactions on Interactive Intelligent Systems (TiiS)}}
%\label{sec-submissaoTIIS}

%\includegraphics{Figuras/RecSys12}


%\pagebreak
%\section{Artigo submetido ao \textit{ACM Recommender Systems 2012}}
%\label{sec-submissaoRecSys}

%\includegraphics{Figuras/RecSys12}

\nocite{*}


\end{document}

