\documentclass[11pt,a4paper,titlepage]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\newcommand{\titulo}{\textit{Relatório V - Pipeline}}

\newcommand{\cabecalho}{\textit{Relatório V}}

\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{setspace}
\usepackage{graphicx,url}
\usepackage[section]{placeins}
%\usepackage{color,colortbl}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{wrapfig}
\usepackage{times}
\usepackage{hyphenat}
\usepackage{ae}
\usepackage{algorithm}
\usepackage[sort,numbers]{natbib}
%package to insert codes
\usepackage{listings}
\usepackage{mips}
\usepackage{tabularx}
\usepackage{makecell}
%appendix
\usepackage[titletoc,toc,page]{appendix}
\renewcommand{\appendixtocname}{Apêndices}
\renewcommand{\appendixpagename}{Apêndices}

% the following is needed for syntax highlighting
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %código assembly
  language=[mips]Assembler,       % the language of the code
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=4,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add a comment within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}
\usepackage{xcolor}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}
%mostrar código do verilog
\lstdefinestyle{verilog-style}
{
    language=Verilog,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    tabsize=8,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1
}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\usepackage{trace}

% Criar figura dividida em subfiguras
\usepackage{subfigure}

\usepackage{subfig}
\usepackage{ae}
\usepackage{aecompl}

\usepackage{multirow}
%\usepackage{epstopdf}

\pagestyle{fancy}

\setlength{\evensidemargin}{0.0in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\textwidth}{6.6in}
\setlength{\textheight}{1.06\textheight}

\lhead{}
\chead{}
\rhead{\footnotesize{\textsc{\cabecalho}}}
\lfoot{\footnotesize{Iuri Silva Castro, João Mateus de Freitas Veneroso, Ricardo Pagoto Marinho}}
\cfoot{}
\rfoot{\footnotesize{\thepage}}
\setlength{\headwidth}{\textwidth}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\baselinestretch}{0.90}

%\hyphenation{ ca-rac-te-ri-zan-do--se }

\begin{document}

\begin{titlepage}
\begin{center}

\begin{large}
Universidade Federal de Minas Gerais\\
Instituto de Ciências Exatas\\
Departamento de Ciência da Computação\\
\end{large}

\vspace{20mm}

\begin{Large}
DCC819 - Arquitetura de Computadores
\end{Large}

\vspace{20mm}

\begin{LARGE}
\titulo
\end{LARGE}


\vspace{30mm}

\begin{Large}
\begin{center}
Iuri Silva Castro\\ João Mateus de Freitas Veneroso\\ Ricardo Pagoto Marinho \\
\end{center}
\end{Large}


\vspace{60mm}

{\sc Belo Horizonte - MG}

{\sc \today}

%\vspace{10mm}
\end{center}
\end{titlepage}

\section{Introdução}\label{sec:desc}

Este documento descreve a implementação do trabalho prático V da disciplina
Organização de Computadores II. O trabalho visou incorporar uma \textit{Pipeline}
de três estágios sobre o caminho de dados implementado nos trabalhos anteriores.
O processador de 16 bits finalizado também faz encaminhamento de dados.

\section{Descrição}\label{sec:desc}

O \textit{Pipeline} é uma técnica de \textit{hardware} para promover paralelismo
à nível de instrução dentro de um único processador. O objetivo da técnica é 
manter todas os módulos do processador ocupados com alguma instrução pelo
máximo de tempo possível. Esse objetivo é realizado por meio da divisão das 
instruções em múltiplas etapas sequenciais, de forma que diferentes etapas de
diferentes instruções possam ser executadas em paralelo como em uma linha de 
montagem. Essa técnica permite aumentar consideravelmente a velocidade do processador
em comparação à execução puramente sequencial, pois várias tarefas podem ser
executadas em um mesmo ciclo de \textit{clock}.

No entanto, a técnica de \textit{Pipelining} complexifica o controle do 
processador, uma vez que a execução paralela introduz \textit{Hazards} no caminho
de dados que não existiriam no caso da execução sequencial:

\begin{itemize}

\item \textit{Hazards Estruturais} impõem restrições no número de instruções que podem
utilizar um módulo do processador ao mesmo tempo. No caso do nosso processador,
o caminho de dados possui uma única via, portanto existe apenas um módulo para 
executar cada etapa da \textit{Pipeline}. 

\item \textit{Hazards de Dados} forçam que uma instrução dependente de dados
de instruções anteriores espere até que os resultados estejam disponíveis antes
de ser executada. Caso não haja encaminhamento de dados, o processador é forçado
a paralizar a execução de novas instruções por meio de \textit{stalls} até que
o dado esteja disponível. Nosso processador implementa o encaminhamento de dados
da saída da unidade multiplicadora e da Unidade Lógica Aritmética para evitar
o \textit{stall}.

\item \textit{Hazards de Controle} acontecem quando existe um desvio de fluxo
que altera o \textit{Program Counter} e torna a próxima execução indefinida até
que o processador avalie o novo valor do \textit{Program Counter}. Nosso processador
introduz um \textit{stall} nos \textit{branches} com o intuito de terminar a 
avaliação do \textit{Program Counter} antes de prosseguir com a execução da próxima
instrução.

\end{itemize}

O processador desenvolvido até o trabalho prático IV executava instruções de maneira
sequencial. Com a introdução do \textit{Pipeline} neste trabalho, obtivemos ganhos
significativos na velocidade de execução como será mostrado na seção de experimentos.

\section{Implementação}

O processador finalizado conta com quatro módulos principais, além de uma série de módulos
de controle secundários e multiplexadores. Os módulos principais são:

\begin{itemize}

\item \textit{Decoder}: recebe a instrução de 16 bits e decodifica o \textit{Opcode},
identificando os operandos e preparando os registradores que sinalizam se a instrução é uma 
multiplicação, se é um \textit{Jump}, se haverá \textit{Stall}, se haverá \textit{Write Back},
qual registrador da multiplicação será armazenado se for o caso e se o segundo operando é
um imediato.

\item \textit{Register Bank}: o banco de registradores conta com 16 registradores de 16 bits,
duas portas de leituras para os operandos A e B e uma porta de escrita.

\item \textit{Unidade Lógica Aritmética}: a unidade lógica aritmética executa as instruções: 
ADD, SUB, SLT, AND, OR, XOR e BEZ.

\item \textit{Unidade multiplicadora}: a unidade multiplicadora recebe dois operandos de 16-bits
e executa uma multiplicação produzindo um resultado de 32-bits que é armazenado em dois registradores:
HI, que armazena os 16-bits mais significativos e LO, que armazena os 16-bits menos significativos.
O resultado da operação armazenado nos registradores pode ser acessado por meio das instruções 
GHI e GLO, que escrevem o conteúdo dos registradores HI e LO, respectivamente, em um registrador
do banco de registradores.

\end{itemize}

\begin{table}[!h]
\centering
\begin{tabular}{| c | c | c | c | c | l |}
\hline
Instrução & Opcode & Bits 11-8 & Bits 7-4 & Bits 3-0 & Descrição \\
\hline
\hline
 ADD  & 0000 & C & A & B   & Reg(C) = Reg(A) + Reg(B) \\
\hline
 SUB  & 0001 & C & A & B   & Reg(C) = Reg(A) - Reg(B) \\
\hline
 SLTI & 0010 & C & A & Imm & Reg(C) = Reg(A) > Imm \\
\hline
 AND  & 0011 & C & A & B   & Reg(C) = Reg(A) AND Reg(B) \\
\hline
 OR   & 0100 & C & A & B   & Reg(C) = Reg(A) OR Reg(B) \\
\hline
 XOR  & 0101 & C & A & B   & Reg(C) = Reg(A) XOR Reg(B) \\
\hline
 ANDI & 0110 & C & A & Imm & Reg(C) = Reg(A) + Imm \\
\hline
 ORI  & 0111 & C & A & Imm & Reg(C) = Reg(A) OR Imm \\
\hline
 XORI & 1000 & C & A & Imm & Reg(C) = Reg(A) XOR Imm \\
\hline
 ADDI & 1001 & C & A & Imm & Reg(C) = Reg(A) + Imm \\
\hline
 SUBI & 1010 & C & A & Imm & Reg(C) = Reg(A) - Imm \\
\hline
 J    & 1011 & \multicolumn{3}{c|}{Imm} & PC = Imm \\
\hline
 BEZ  & 1100 & - & A & B   & If (Reg(A) = 0) PC = Reg(B) \\
\hline
 MUL  & 1101 & C & A & B   & Reg(C) = Reg(A) * Reg(B) \\
\hline
 GHI  & 1110 & C & - & -   & Reg(C) = HI \\
\hline
 GLO  & 1111 & C & - & -   & Reg(C) = LO \\
\hline
\end{tabular}
\caption{Instruções}
\label{tab:instructions}
\end{table}
\captionsetup{font={footnotesize,rm},justification=centering,labelsep=period}%

O conjunto de instruções final do processador está descrito na tabela \ref{tab:instructions}.
Todas as instruções aritméticas e lógicas recebem o operando A do banco de registradores e o
operando B pode ser um imediato de 4-bits ou um registrador dependendo da instrução. A instrução
BEZ não utiliza os bits 11-8 e as instruções GHI e GLO não utilizam os bits de 7-0. A instrução
J altera o PC para um valor imediato de 12-bits que comporta qualquer endereço da memória de
4096 posições.

\section{Integração}

Mostrar divisão de estágios. Mostrar buffers entre estágios. Mostrar sistema inteiro
Adicionar diagrama da pipeline.
Adicionar diagrama da estrutura do processador.

\section{Simulação e Testes}

Descrever processo de simulação e programas de teste. Comparar programas rodando com pipeline e sem (trabalho IV anterior).


\section{Discussões}

Comentar dos ganhos de desempenho, custos dos \textit{Stalls}, dificuldades de mudança para pipeline.


\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Referências}
%\bibliography{references}

\nocite{*}


\end{document}

